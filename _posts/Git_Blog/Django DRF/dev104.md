---

layout: single
title: " [Django DRF] project (4) "
categories: Django
tag: [Python,"[Django DRF] Project eCommerce RESTful API","[Django DRF] Product Media"]
toc: true
toc_sticky: true
author_profile: false
sidebar:

---

# Product Attributes

## Build : Implementing the Attribute Models


![](https://i.imgur.com/D3XJFrN.png)

기존의 Attributes Values 테이블과 ProductLine 테이블은 다대다 관계였지만 다대다 관계에서는 특정 송성값이 중복되지 않도록 막거나 유효성을 검사하는 등의 작업을 하기 어렵다.     

예를 들어 주문과 주문 상품 사이의 관계에서 중간 테이블에 수량 필드를 추가하거나, 특정 상품이 한 주문 내에서 중복되지 않도록 제약 조건을 설정하기 어렵다.    

결론적으로 복잡한 조작이 필요한 상황에서는 OneToManyField 를 사용하는게 관계를 더 세밀하게 제어할 수 있기 때문에 상황에 따라 쓰면 된다.     

models.py
![](https://i.imgur.com/UTb45N7.png)
![](https://i.imgur.com/STso1l3.png)
![](https://i.imgur.com/ytc4ECB.png)
- Attribute 모델: 속성을 나타내는 모델이다. name과 description 필드를 가지고 있다.
- AttributeValue 모델: 속성의 값을 나타내는 모델이다. attribute_value와 attribute 필드를 가지고 있으며, attribute 필드는 Attribute 모델과의 외래 키 관계다.
- ProductLineAttributeValue 모델: 상품 라인과 속성 값 간의 중간 테이블을 나타내는 모델이다. attribute_value와 product_line 필드를 가지고 있으며, 각각 AttributeValue와 ProductLine 모델과의 외래 키 관계다. Meta 클래스에서 unique_together 속성을 사용하여 attribute_value와 product_line 필드의 값이 유일하게 유지되도록 설정했다.
- ProductLine 모델: 상품 라인을 나타내는 모델이다. price, sku, stock_qty, product 등의 필드를 가지고 있으며, attribute_value 필드는 ManyToManyField를 사용하여 AttributeValue 모델과의 관계를 나타냅니다. through 옵션을 사용하여 ProductLineAttributeValue 모델을 통해 중간 테이블을 지정했다. clean 메서드를 사용하여 중복된 order 값을 가지는 객체를 방지하고, save 메서드를 오버라이딩하여 유효성 검사를 수행한 후 저장한다.

이 코드는 속성과 속성 값, 그리고 상품 라인 간의 관계를 정의하고, 중간 테이블을 사용하여 관계를 관리한다. 각 모델은 필요한 필드와 외래 키 관계를 정의하고, through 옵션을 사용하여 중간 테이블을 지정한다. 이를 통해 복잡한 관계를 다룰 수 있고, 중간 테이블에 추가적인 필드나 제약 조건을 설정할 수 있다.     

### unique_together

unique_together는 Django 모델의 Meta 클래스에서 사용되는 옵션 중 하나로, 여러 필드의 조합이 고유(unique)해야 함을 지정하는 기능이다. 즉, 지정된 필드들의 값들이 중복되지 않도록 제약 조건을 설정할 수 있다.    

예를 들어, unique_together를 사용하여 "attribute_value"와 "product_line" 필드의 조합이 고유해야 함을 설정할 수 있다. 이는 "attribute_value"와 "product_line"의 값이 같은 조합이 중복되지 않도록 하는 제약 조건을 생성한다.     

다음은 예시 코드다:
```python
class ProductLineAttributeValue(models.Model):
    attribute_value = models.ForeignKey(AttributeValue, on_delete=models.CASCADE, related_name="product_attribute_value_av")
    product_line = models.ForeignKey(ProductLine, on_delete=models.CASCADE, related_name="product_attribute_value_pl")

    class Meta:
        unique_together = ("attribute_value", "product_line")

```

위 코드에서 "attribute_value"와 "product_line" 필드의 조합이 고유해야 함을 설정했다. 이제 같은 "attribute_value"와 "product_line" 값을 가지는 조합이 중복되지 않도록 제약 조건이 적용된다.     

예를 들어, 다음과 같은 데이터가 있다고 가정해보자:     

attribute_value: A, B, C product_line: X, Y, Z     

이때, 다음과 같은 조합이 유효하다고 가정한다:      

(A, X), (B, Y), (C, Z)      

하지만, 다음과 같은 조합은 중복이므로 유효하지 않는다:      

(A, X), (B, X), (C, Z)      

unique_together를 사용하여 중복된 조합을 방지하면 데이터의 일관성을 유지할 수 있고, 잘못된 조합이 생성되는 것을 방지할 수 있다.     

### through

Django의 ManyToManyField에서 through 옵션은 관계의 중간에 직접적인 링크 테이블(link table)을 정의하고자 할 때 사용된다. 일반적으로 ManyToManyField는 자동으로 생성되는 링크 테이블을 사용하여 관계를 처리하지만, through 옵션을 사용하면 개발자가 직접 링크 테이블을 정의하고 추가적인 필드를 포함시킬 수 있다.     

through 옵션을 사용하여 링크 테이블을 정의할 때는 중간 모델(intermediate model)을 생성해야 합니다. 이 중간 모델은 ManyToManyField를 연결하는 데 사용되며, 중간 모델에는 추가적인 필드를 포함할 수 있다.      

위 코드에서 `ProductLine` 모델의 `attribute_value` 필드는 ManyToMany 관계를 정의하는데, `ProductLineAttributeValue` 모델을 중간 모델로 사용하도록 설정했다.     
`ProductLineAttributeValue` 모델은 `AttributeValue`와 `ProductLine` 사이의 관계를 매핑하며, 추가적인 필드를 포함하고 있다.       

이 예시에서 `ProductLineAttributeValue` 모델은 `attribute_value`와 `product_line` 필드로 ForeignKey를 가지고 있으며, 중간 모델의 `Meta` 클래스에서 `unique_together`를 사용하여 두 필드의 조합이 고유해야 함을 설정했다. 이렇게 함으로써 중복된 조합이 생성되지 않도록 제약 조건을 설정할 수 있다.      

through 옵션을 사용하여 직접 링크 테이블을 정의하면, 중간 모델에 추가적인 필드를 포함하여 관계에 대한 세부 정보를 저장하거나 추적할 수 있다. 이를 통해 더 복잡한 관계를 다루거나 관계에 대한 추가적인 정보를 저장하는 등의 작업을 수행할 수 있다.      

## Build : Admin Site Attribute Value Inlines

admin.py
![](https://i.imgur.com/fNQ60KB.png)

models.py
![](https://i.imgur.com/b2j5olR.png)

- `AttributeValueInline` 클래스는 `ProductLineAdmin` 페이지에서 `ProductLine` 모델과 함께 인라인으로 표시되는 `AttributeValue` 모델을 설정한다. `AttributeValue`와 `ProductLine` 사이의 관계를 통해 링크 테이블을 처리하도록 설정한다.
    
- `ProductLineAdmin` 클래스는 `ProductLine` 모델을 관리하기 위한 설정을 제공한다. `ProductImageInline` 클래스와 `AttributeValueInline` 클래스를 인라인으로 표시하도록 설정한다.

`AttributeValue.product_line_attribute_value.through` 는 `AttributeValue` 모델과 `ProductLine` 모델 사이의 링크 테이블에 대한 참조다.      

ManyToManyField를 사용하여 관계를 설정할 때 Django는 자동으로 링크 테이블을 생성한다. 이 링크 테이블은 두 모델 사이의 관계를 유지하고 관리한다.      `through` 속성을 사용하면 링크 테이블에 직접적으로 접근할 수 있다.      

위의 코드에서 `AttributeValueInline` 클래스에서 `AttributeValue.product_line_attribute_value.through`를 설정했다. 이를 통해 `AttributeValue`와 `ProductLine` 사이의 링크 테이블을 처리할 수 있다. `through` 속성을 사용하여 링크 테이블의 모델을 지정하고, 이를 통해 `AttributeValue`와 `ProductLine` 사이의 관계를 조작할 수 있다.      

예를 들어, `AttributeValue`와 `ProductLine` 사이의 링크 테이블에 새로운 연결을 생성하려면 다음과 같이 할 수 있다:     
```python
attribute_value = AttributeValue.objects.get(id=1)
product_line = ProductLine.objects.get(id=1)
link = attribute_value.product_line_attribute_value.through(attribute_value=attribute_value, product_line=product_line)
link.save()
```

링크 테이블을 통해 `AttributeValue`와 `ProductLine` 사이의 추가 데이터를 저장하고 관리할 수 있다. 이를 통해 두 모델 간의 많은 관계를 조작할 수 있다.      

![](https://i.imgur.com/ZvxuzJ8.png)

## Build : Product Attribute Serializer

![](https://i.imgur.com/ZOgrqrM.png)
![](https://i.imgur.com/deripqA.png)

현재 속성을 추가하면 숫자만 나오는 상태인데 이렇게 되면 프론트 쪽에서 뭔지 알기가 힘들다. 따라서 이름도 같이 나오게 만드는게 좋다.     

serializers.py

```python
class AttributeSerializer(serializers.ModelSerializer):
    class Meta:
        model = Attribute
        fields = ("name", "id")

class AttributeValueSerializer(serializers.ModelSerializer):
    attribute = AttributeSerializer(many=False)
    class Meta:
        model = AttributeValue
        fields = (
            "attribute",
            "attribute_value",
        )

class ProductLineSerializer(serializers.ModelSerializer):
    product_image = ProductImageSerializer(many=True)
    attribute_value = AttributeValueSerializer(many=True)

    class Meta:
        model = ProductLine
        fields = (
            "price",
            "sku",
            "stock_qty",
            "order",
            "product_image",
            "attribute_value",

        )
```

admin.py
![](https://i.imgur.com/oTCPywI.png)

`product_line_attribute_value.through`는 `AttributeValue` 모델과 `ProductLine` 모델 간의 링크 테이블을 가리키는 참조다.

`AttributeValueInline` 클래스에서 `model` 속성을 `AttributeValue.product_line_attribute_value.through`로 설정함으로써, `AttributeValue`와 `ProductLine` 사이의 링크 테이블을 관리하는 데 사용된다.     

링크 테이블은 `ManyToManyField` 관계에서 자동으로 생성되는 중간 테이블이다. 이 테이블은 `AttributeValue`와 `ProductLine`의 관계를 기록하고 유지한다. `through` 속성을 사용하여 링크 테이블의 모델을 지정하면, 해당 모델을 통해 링크 테이블에 직접 접근할 수 있다.     

위의 코드에서 `AttributeValueInline` 클래스에서 `model` 속성을 `AttributeValue.product_line_attribute_value.through`로 설정했으므로, 링크 테이블을 관리하는 데 사용되는 모델을 지정하게 된다. 이를 통해 `AttributeValue`와 `ProductLine` 사이의 관계를 효율적으로 다룰 수 있다.     

예를 들어, `AttributeValueInline` 인라인 모델을 사용하여 `ProductLineAdmin`에 속성 값을 인라인으로 표시할 수 있다. 이를 통해 특정 `ProductLine`의 속성 값들을 관리하고 편집할 수 있다.


models.py
**![](https://i.imgur.com/MnN7m9j.png)

위의 코드는 `ProductLine` 모델에서 `attribute_value` 필드를 정의하는 부분이다.     

`attribute_value`는 `ManyToManyField` 관계로 선언되었다. 이 필드는 `AttributeValue` 모델과의 다대다 관계를 나타낸다.     

`through` 매개변수를 사용하여 중간 테이블을 지정했다. 중간 테이블은 `ProductLineAttributeValue` 이다. 이를 통해 `ProductLine`과 `AttributeValue` 사이의 관계를 기록하고 유지한다.     

`related_name` 매개변수는 `ProductLine` 모델에서 `AttributeValue`에 역참조할 때 사용할 이름을 지정한다. 위의 코드에서는 `"product_line_attribute_value"`로 설정되었다.     

이 관계를 통해 `ProductLine`과 `AttributeValue`는 다대다 관계를 가지며, 중간 테이블 `ProductLineAttributeValue`를 통해 서로를 연결한다.      `ProductLineAttributeValue` 모델은 중간 테이블을 다루는 역할을 하며, `ProductLine`과 `AttributeValue` 사이의 속성 값을 저장하고 관리한다.     

이렇게 설정된 `attribute_value` 필드를 통해 `ProductLine` 인스턴스와 관련된 속성 값들을 효율적으로 다룰 수 있다. 예를 들어, 특정 `ProductLine`의 속성 값을 가져오거나 수정하는 등의 작업을 수행할 수 있다.     

![](https://i.imgur.com/9UnMtA7.png)

## Design : Product Types and Type Attributes

![](https://i.imgur.com/mrtAM3J.png)

위와 같이 선택할 옵션이 많아질 경우 컨트롤 하기가 어려워진다.     
따라서 중간에 Product type 테이블을 만든 후 거기에 속성 값을 나눠줘야 한다.

![](https://i.imgur.com/jGw0pLc.png)

## Build : Implementing the Product Type Tables

[모델 필드 레퍼런스 공문](https://docs.djangoproject.com/en/4.2/ref/models/fields/)

![](https://i.imgur.com/wV1RTsh.png)


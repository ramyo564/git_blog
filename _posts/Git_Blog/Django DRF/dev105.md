---

layout: single
title: " [Django DRF] project (5) "
categories: Django
tag: [Python,"[Django DRF] Project eCommerce RESTful API","[Django DRF] Model and Model Testing Iteration"]
toc: true
toc_sticky: true
author_profile: false
sidebar:

---
# Model and Model Testing Iteration

이제부터 데이터베이스를 개선해서 다양한 유형의 제품과 해당 데이터를 저장하는 유연성을 향상 시킬 예정이다.

## Design : Implementing Database Structure Changes

직접적으로 Brand 모델을 작업하는 경우에는 브랜드의 이름, 주소, 사업자 번호 등과 같은 정보를 기록할 수 있다. 이러한 정보는 브랜드 테이블에 확장될 수 있다.     
하지만 현재는 단순히 브랜드 이름만 저장하는 상태이다.     

브랜드 테이블은 현재 브랜드의 이름과 해당 브랜드가 사용 중인지 여부(활성 상태)만 저장하고 있다. 브랜드 레이블을 갖고 있기 때문에 제품 테이블에서 해당 브랜드 이름을 한 번만 입력하거나 삽입할 수 있다. 이로써 제품 테이블에서 모든 제품이 동일한 브랜드를 사용하는 경우에도 브랜드 이름이 중복되지 않게 된다. 예를 들어 1000개의 제품이 모두 동일한 브랜드를 사용한다면 브랜드 이름이 중복된 열이 없을 거다.     

현재는 아래와 같은 개념으로만 테이블이 정리되어있다.     
![](https://i.imgur.com/YLFRcDa.png)

새롭게 변경한 테이블 관계다.    
![](https://i.imgur.com/bjskUOS.png)

이제 제품과 관련된 속성을 저장할 수 있는 기능을 만들었다.    
해당 속성은 제품과 관련된 모든 프로덕트 라인에 소유된다.     
제품과 속성 값 사이를 연결 시켰는데 한 제품은 여러 속성 값을 가질 수 있고, 한 속성값은 여러 제품에 연결될 수 있다. 따라서 여기서는 다대다 연결을 사용한다.     

또한 프로덕트 타입과 프로덕트 라인의 연결간의 일대다 연결은 너무 많은 속성들이 한 번에 보여진다면 상당히 많은 메모리가 할당 될 수 있다. 따라서 위와 같이 관계를 만들었다.    

## Build : Category table iteration

models.pu
```python
  

from django.db import models

from mptt.models import MPTTModel, TreeForeignKey

from .fields import OrderField

from django.core.exceptions import ValidationError

  
  
class Category(MPTTModel):

    name = models.CharField(max_length=255, unique=True)

    slug = models.SlugField(max_length=255, unique=True)

    is_active = models.BooleanField(default=False)

    parent = TreeForeignKey("self", on_delete=models.PROTECT, null=True, blank=True)

    objects = IsActiveQueryset.as_manager()

  

    class MPTTmeta:

        order_insertion_by = ['name']

  

    def __str__(self):

        return self.name
```

## Testing : Category Testing Iteration

### factories.py
```python
class CategoryFactory(factory.django.DjangoModelFactory):

    class Meta:

        model = Category

  

    name = factory.Sequence(lambda n: "Category_%d" % n)

    slug = factory.Sequence(lambda n: "test_slug_%d" % n)
```

현재 모델에서 여러가지로 값을 넣을 수 있는 slug를 추가 해주고 모델 테스트를 진행한다.

### test_models.py
```python
  

class TestCategoryModel:

    def test_str_method(self, category_factory):

        x = category_factory(name="test_cat")

        assert x.__str__() == "test_cat"

  

    def test_name_max_length(self, category_factory):

        name = "x" * 256

        obj = category_factory(name=name)

        with pytest.raises(ValidationError):

            obj.full_clean()

  

    def test_name_unique_field(self, category_factory):

        category_factory(name="test_cat")

        with pytest.raises(IntegrityError):

            category_factory(name="test_cat")

  

    def test_is_active_false_default(self, category_factory):

        obj = category_factory()

        assert obj.is_active is False

  

    def test_parent_category_on_delete_protect(self, category_factory):

        obj1 = category_factory()

        category_factory(parent=obj1)

        with pytest.raises(IntegrityError):

            obj1.delete()

  

    def test_parent_field_null(self, category_factory):

        obj1 = category_factory()

        assert obj1.parent is None

  

    def test_return_category_active_only_true(self, category_factory):

        category_factory(is_active=True)

        category_factory(is_active=False)

        qs = Category.objects.is_active().count()

        assert qs == 1
```

1. `test_str_method`: `category_factory`를 이용하여 카테고리 인스턴스를 생성한 후, `__str__()` 메서드가 올바르게 동작하는지 테스트한다. `__str__()` 메서드는 카테고리의 이름을 반환해야 한다.
    
2. `test_name_max_length`: `category_factory`를 이용하여 이름의 최대 길이를 초과하는 카테고리 인스턴스를 생성하고, 해당 인스턴스를 저장할 때 `ValidationError` 예외가 발생하는지 테스트한다. 이름의 최대 길이는 255로 설정되어 있는데, 이를 초과하면 유효성 검사에 실패한다.
    
3. `test_name_unique_field`: `category_factory`를 이용하여 동일한 이름을 가진 두 개의 카테고리 인스턴스를 생성하고, 두 번째 인스턴스를 저장할 때 `IntegrityError` 예외가 발생하는지 테스트한다. 이름 필드는 유일해야 하므로, 중복된 이름을 가진 인스턴스를 저장할 수 없다.
    
4. `test_is_active_false_default`: `category_factory`를 이용하여 카테고리 인스턴스를 생성한 후, `is_active` 필드가 기본값인 False로 설정되는지 테스트한다.
    
5. `test_parent_category_on_delete_protect`: `category_factory`를 이용하여 두 개의 카테고리 인스턴스를 생성하고, 두 번째 인스턴스의 부모 필드를 첫 번째 인스턴스로 설정한 후, 첫 번째 인스턴스를 삭제할 때 `IntegrityError` 예외가 발생하는지 테스트한다. 부모 카테고리를 삭제할 때, 연관된 자식 카테고리가 삭제되지 않도록 `on_delete=PROTECT` 설정이 되어 있어야 한다.
    
6. `test_parent_field_null`: `category_factory`를 이용하여 카테고리 인스턴스를 생성한 후, 해당 인스턴스의 부모 필드가 기본값인 None인지 테스트한다. 즉, 부모 카테고리가 없는 경우, 부모 필드가 None이 되어야 한다.
    
7. `test_return_category_active_only_true`: `category_factory`를 이용하여 활성화된(is_active=True) 카테고리와 비활성화된(is_active=False) 카테고리를 각각 하나씩 생성한 후, `Category.objects.is_active().count()`를 통해 활성화된 카테고리만을 쿼리하여 개수를 확인하는 테스트한다. 이 테스트에서는 `is_active()`라는 사용자 정의 쿼리셋 메서드가 제대로 동작하는지 확인한다.
    
```javascript
function combine(a,b,c){
	return a * b / c
}
```